#version 460
#extension GL_EXT_ray_tracing : require

const int MAX_LIGHTS = 3;

layout(binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1) uniform sampler2D  Position;
layout(binding = 2) uniform sampler2D  Normal;
layout(binding = 3, rgba8) uniform image2D OutputImage;

layout(binding = 4) uniform CameraProperties {

    mat4 ViewMatrix;
    mat4 ProjectionMatrix;
    vec4 LightCount_WithPadding;

} cam;

struct LightStruct {

    vec4 LightDirection;
    vec4 LightType_WithPadding;

};

layout(binding = 5) uniform LightInformation {

   LightStruct LightData[2]; 
    
} Light_UBO;

struct HitPayload {

    bool Shadowed;
    bool SkyBox;

};

layout(location = 0) rayPayloadEXT HitPayload PayloadResults;

bool TraceShadow(vec3 origin, vec3 direction) {

    PayloadResults.Shadowed = true;
    PayloadResults.SkyBox = false;

    const uint rayFlags = gl_RayFlagsOpaqueEXT;
    const uint cullMask = 0xff;
    const float tMin = 0.001;
    const float tMax = 10000.0;

    traceRayEXT(
        topLevelAS,
        rayFlags,
        cullMask,
        0, 0, 0,
        origin,
        tMin,
        direction,
        tMax,
        0
    );

    return PayloadResults.Shadowed;
}

void main() {

   
   vec3 FinalColor = vec3(0);

   vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);

   //////////////////////////FOR SKYBOX ////////////////////////////////////////////////////
   vec2 d   = inUV * 2.0 - 1.0; // conver to clipspace

   vec4 SkyBoxOrigin    =    cam.ViewMatrix * vec4(0,0,0,1);
   vec4 SkyBoxtarget    =    cam.ProjectionMatrix * vec4(d.x, d.y, 1, 1) ;
   vec4 SkyBoxdirection =    cam.ViewMatrix * vec4(normalize(SkyBoxtarget.xyz / SkyBoxtarget.w), 0) ;

   uint rayFlags  = gl_RayFlagsOpaqueEXT;
   uint cullMask  = 0xff;
   float tmin     = 0.001;
   float tmax     = 10000.0;

   PayloadResults.SkyBox = false;

   traceRayEXT(topLevelAS, rayFlags, cullMask, 0, 0, 0, SkyBoxOrigin.xyz, tmin, SkyBoxdirection.xyz, tmax, 0);

   vec3 SkyBoxColor = vec3(1,0,0);

   if(PayloadResults.SkyBox){
       
       FinalColor = SkyBoxColor;
   }

   ////////////////////////////////////////////////////////////////////////////////////////////

   if(PayloadResults.SkyBox == false){
   
       FinalColor = vec3(1);
       bool BShadows[MAX_LIGHTS];
       
       const int LightCount   = int(floor(cam.LightCount_WithPadding.x));
       
       vec3 hitPosition = texture(Position, inUV).xyz;
       
       
       vec3 origin  = hitPosition;
            origin  += 0.01;
       
       
       
       for(int i = 0; i < LightCount; ++i){
          
            if(Light_UBO.LightData[i].LightType_WithPadding.x == 0.0){
                BShadows[i] = TraceShadow(origin,-Light_UBO.LightData[i].LightDirection.xyz);
            }       
       };
       
       // Combine shadows from both lights
       vec3 totalShadowColor;
       
       if (BShadows[0] && BShadows[1] && BShadows[2]) {
           totalShadowColor = vec3(0.0); // fully in shadow
       } else if (BShadows[0] || BShadows[1] || BShadows[2]) {
           totalShadowColor = vec3(0.2); // partial light
       } else {
           totalShadowColor = vec3(1.0); // fully lit
       
       }
       
       FinalColor = totalShadowColor;       
  }

    imageStore(OutputImage, ivec2(gl_LaunchIDEXT.xy), vec4(FinalColor, 1.0));

}
