#version 460
#extension GL_EXT_ray_tracing : require

const int MAX_LIGHTS = 4;

layout(binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1) uniform sampler2D Position;
layout(binding = 2) uniform sampler2D Normal;
layout(binding = 3, rgba8) uniform image2D OutputImage[4];

layout(binding = 4) uniform CameraProperties {
    mat4 ViewMatrix;
    mat4 ProjectionMatrix;
    vec4 LightCount_NumOfLightCasters_Padding;
} cam;

struct LightStruct {
    vec4 LightPositions;
    vec4 LightType_CastShadow_AmbientStrength_Padding;
};

layout(binding = 5) uniform LightInformation {
   LightStruct LightData[3]; 
} Light_UBO;

struct HitPayload {
    bool Shadowed;
};

layout(location = 0) rayPayloadEXT HitPayload PayloadResults;

bool TraceShadow(vec3 origin, vec3 direction, float MaxDistance) {
    // Initialize payload before tracing
    PayloadResults.Shadowed = true; // Start with not shadowed

    const uint rayFlags = gl_RayFlagsOpaqueEXT | 
                         gl_RayFlagsTerminateOnFirstHitEXT | 
                         gl_RayFlagsSkipClosestHitShaderEXT | 
                         gl_RayFlagsCullBackFacingTrianglesEXT;
    const uint cullMask = 0xFF;
    const float tMin = 0.001;
    const float tMax = MaxDistance;

    traceRayEXT(
        topLevelAS,
        rayFlags,
        cullMask,
        0,      // sbtRecordOffset
        0,      // sbtRecordStride
        0,      // missIndex
        origin,
        tMin,
        direction,
        tMax,
        0       // payload location (0 is already specified in layout)
    );

    return PayloadResults.Shadowed;
}

vec3 offsetPositionAlongNormal(vec3 ViewPosition, vec3 normal)
{

    return ViewPosition + 0.01 * normal;

}


void main() {
    float shadowFactor[MAX_LIGHTS] = {1.0, 1.0,1.0,1.0};
    
    ivec2 halfCoord  = ivec2(gl_LaunchIDEXT.xy);
    ivec2 fullCoord = halfCoord * 2; 
    vec3 hitPosition = texelFetch(Position, fullCoord, 0).xyz;
    
    // Add small bias to avoid self-intersection
    vec3 normal = texelFetch(Normal, fullCoord, 0).xyz;
     vec3 origin = offsetPositionAlongNormal(hitPosition,normal); 

    for(int i = 0; i < MAX_LIGHTS; ++i) {
        // Check if light exists and casts shadows
        if(Light_UBO.LightData[i].LightType_CastShadow_AmbientStrength_Padding.y > 0.5) {
            
             vec3 lightDir;
             float maxDistance;
             
             // Directional light (type 0)
             if(Light_UBO.LightData[i].LightType_CastShadow_AmbientStrength_Padding.x < 0.5) {
                 lightDir = normalize(-Light_UBO.LightData[i].LightPositions.xyz);
                 maxDistance = 10000.0;
             } 
             // Point light (type 1)
             else {
                 vec3 toLight = Light_UBO.LightData[i].LightPositions.xyz - hitPosition;
                 maxDistance = length(toLight);
                 lightDir = normalize(toLight);
             }
             
             // Trace shadow ray
             bool isShadowed = TraceShadow(origin, lightDir, maxDistance);
             
             if(isShadowed) {
                 shadowFactor[i] = 0.0 + Light_UBO.LightData[i].LightType_CastShadow_AmbientStrength_Padding.z;
             }
        }
    }

    // Store results
    imageStore(OutputImage[0], halfCoord, vec4(shadowFactor[0], shadowFactor[1], shadowFactor[2],shadowFactor[3]));
    imageStore(OutputImage[1], halfCoord, vec4(shadowFactor[0], shadowFactor[1], shadowFactor[2], 1.0));
    //imageStore(OutputImage[2], texCoord, vec4(shadowFactor[2], shadowFactor[2], shadowFactor[2], 1.0));
    //imageStore(OutputImage[3], texCoord, vec4(shadowFactor[3], shadowFactor[3], shadowFactor[3], 1.0));

}