#version 460
#extension GL_EXT_ray_tracing : require

const int MAX_LIGHTS = 2;

layout(binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1) uniform sampler2D Position;
layout(binding = 2) uniform sampler2D Normal;
layout(binding = 3, rgba8) uniform image2D OutputImage[2];

layout(binding = 4) uniform CameraProperties {
    mat4 ViewMatrix;
    mat4 ProjectionMatrix;
    vec4 LightCount_NumOfLightCasters_Padding;
} cam;

struct LightStruct {
    vec4 LightPositions;
    vec4 LightType_CastShadow_Padding;
};

layout(binding = 5) uniform LightInformation {
   LightStruct LightData[2]; 
} Light_UBO;

struct HitPayload {
    bool Shadowed;
};

layout(location = 0) rayPayloadEXT HitPayload PayloadResults;

bool TraceShadow(vec3 origin, vec3 direction, float MaxDistance) {
    // Initialize payload before tracing
    PayloadResults.Shadowed = true; // Start with not shadowed

    const uint rayFlags = gl_RayFlagsOpaqueEXT | 
                         gl_RayFlagsTerminateOnFirstHitEXT | 
                         gl_RayFlagsSkipClosestHitShaderEXT | 
                         gl_RayFlagsCullBackFacingTrianglesEXT;
    const uint cullMask = 0xFF;
    const float tMin = 0.001;
    const float tMax = MaxDistance;

    traceRayEXT(
        topLevelAS,
        rayFlags,
        cullMask,
        0,      // sbtRecordOffset
        0,      // sbtRecordStride
        0,      // missIndex
        origin,
        tMin,
        direction,
        tMax,
        0       // payload location (0 is already specified in layout)
    );

    return PayloadResults.Shadowed;
}

vec3 offsetPositionAlongNormal(vec3 ViewPosition, vec3 normal)
{
    return ViewPosition + 0.1 * normal;
}


void main() {
    float shadowFactor[MAX_LIGHTS] = {1.0, 1.0};
    
    ivec2 texCoord = ivec2(gl_LaunchIDEXT.xy);
    vec3 hitPosition = texelFetch(Position, texCoord, 0).xyz;
    
    // Add small bias to avoid self-intersection
    vec3 normal = texelFetch(Normal, texCoord, 0).xyz;
     vec3 origin = offsetPositionAlongNormal(hitPosition,normal); 

    for(int i = 0; i < MAX_LIGHTS; ++i) {
        // Check if light exists and casts shadows
        if(i < int(cam.LightCount_NumOfLightCasters_Padding.x) && 
           Light_UBO.LightData[i].LightType_CastShadow_Padding.y > 0.5) {
            
            vec3 lightDir;
            float maxDistance;
            
            // Directional light (type 0)
            if(Light_UBO.LightData[i].LightType_CastShadow_Padding.x < 0.5) {
                lightDir = normalize(-Light_UBO.LightData[i].LightPositions.xyz);
                maxDistance = 10000.0;
            } 
            // Point light (type 1)
            else {
                vec3 toLight = Light_UBO.LightData[i].LightPositions.xyz - hitPosition;
                maxDistance = length(toLight);
                lightDir = normalize(toLight);
            }
            
            // Trace shadow ray
            bool isShadowed = TraceShadow(origin, lightDir, maxDistance);
            
            if(isShadowed) {
                shadowFactor[i] = 0.0;
            }
        }
    }

    // Store results
    imageStore(OutputImage[0], texCoord, vec4(shadowFactor[0], shadowFactor[0], shadowFactor[0], 1.0));
    imageStore(OutputImage[1], texCoord, vec4(shadowFactor[1], shadowFactor[1], shadowFactor[1], 1.0));
}