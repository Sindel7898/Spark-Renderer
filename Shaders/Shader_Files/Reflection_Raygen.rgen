#version 460
#extension GL_EXT_ray_tracing : require

layout(binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1) uniform sampler2D Position;
layout(binding = 2) uniform sampler2D Normal;
layout(binding = 3, rgba8) uniform image2D OutputImage;

struct ReflectionPayload {
    vec3 Color;
};

layout(location = 0) rayPayloadEXT ReflectionPayload reflPayload;

vec3 TraceReflection(vec3 origin, vec3 direction) {
    const uint rayFlags = gl_RayFlagsOpaqueEXT | 
                         gl_RayFlagsTerminateOnFirstHitEXT | 
                         gl_RayFlagsCullBackFacingTrianglesEXT;
    const uint cullMask = 0xFF;
    const float tMin = 0.0;
    const float tMax = 10000.0; // Increased for better coverage

    // Initialize payload    
    traceRayEXT(
        topLevelAS,
        rayFlags,
        cullMask,
        0,      // sbtRecordOffset
        0,      // sbtRecordStride
        1,      // missIndex
        origin,
        tMin,
        direction,
        tMax,
        0       // payload location
    );

    return reflPayload.Color;
}

vec3 offsetPositionAlongNormal(vec3 position, vec3 normal) {
    return position + 0.001 * normal; // Smaller offset to avoid self-intersection
}

void main() {
    ivec2 fullCoord = ivec2(gl_LaunchIDEXT.xy);
    vec3 hitPosition = texelFetch(Position, fullCoord, 0).xyz;
    
    
    vec3 normal = texelFetch(Normal, fullCoord, 0).xyz;
    vec3 origin = offsetPositionAlongNormal(hitPosition, normalize(normal)); 
    
    vec3 V = normalize(origin - vec3(0,0,0));
    vec3 direction = reflect(-V, normalize(normal));
    
    vec3 Reflection = TraceReflection(origin, direction);

    imageStore(OutputImage, fullCoord, vec4(Reflection, 1));
}